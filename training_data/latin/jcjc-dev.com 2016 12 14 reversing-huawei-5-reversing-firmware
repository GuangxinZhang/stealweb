<!DOCTYPE html><html lang="en-us"><head>
  <meta property="og:site_name" content="Hack The World">
<meta property="og:type" content="article">
<meta property="og:title" content="Practical Reverse Engineering Part 5 - Digging Through the Firmware">
<meta property="og:image" content="http://imgur.com/plg2HBD">




  
    <meta property="og:see_also" content="http://jcjc-dev.com/2016/06/08/reversing-huawei-4-dumping-flash/">
  
    <meta property="og:see_also" content="http://jcjc-dev.com/2016/05/23/reversing-huawei-3-sniffing/">
  
    <meta property="og:see_also" content="http://jcjc-dev.com/2016/04/29/reversing-huawei-router-2-scouting-firmware/">
  


  <link href="http://gmpg.org/xfn/11" rel="profile">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <script id="twitter-wjs" src="http://platform.twitter.com/widgets.js"></script><script async="" src="//www.google-analytics.com/analytics.js"></script><script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-46103804-1', 'auto');
    ga('send', 'pageview');
  </script>

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Practical Reverse Engineering Part 5 - Digging Through the Firmware · Hack The World
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
<script src="//jcjc-dev.disqus.com/embed.js" data-timestamp="1486149621510"></script><script type="text/javascript" charset="utf-8" async="" src="https://platform.twitter.com/js/button.57411deb997a43b27baa13b432c7631e.js"></script></head>


  <body>

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="/">
          Hack The World
        </a>
      </h1>
      <p class="lead">Projects and learnt lessons on Systems Security, Embedded Development, IoT and anything worth writing about</p>
    </div>

    <nav class="sidebar-nav">

      

      
      
        
          
        
      
        
          
            <a class="sidebar-nav-item" href="/archive/">Archive</a>
          
        
      
        
      
        
          
        
      
        
      
        
          
            <a class="sidebar-nav-item" href="/jekyll_licnse/">Released under MIT License</a>
          
        
      
        
          
        
      

      <a class="sidebar-nav-item" href="https://uk.linkedin.com/in/juan-carlos-jiménez-bba49033/en">Juan Carlos Jimenez</a>
      <a class="sidebar-nav-item" href="https://twitter.com/Palantir555">Twitter</a>
      <a class="sidebar-nav-item" href="https://github.com/Palantir555">GitHub</a>
      <a href="mailto:jcjc.dev@gmail.com?Subject=Hack%20The%20World!" target="_top">e-mail</a>
    </nav>

  </div>
</div>


    <div class="content container">
      <div class="post">
  <h1 class="post-title">Practical Reverse Engineering Part 5 - Digging Through the Firmware</h1>
  <span class="post-date">14 Dec 2016
  </span>
  <ul>
  <li><a href="http://jcjc-dev.com/2016/04/08/reversing-huawei-router-1-find-uart/">Part 1</a>:
Hunting for Debug Ports</li>
  <li><a href="http://jcjc-dev.com/2016/04/29/reversing-huawei-router-2-scouting-firmware/">Part 2</a>:
Scouting the Firmware</li>
  <li><a href="http://jcjc-dev.com/2016/05/23/reversing-huawei-3-sniffing/">Part 3</a>:
Following the Data</li>
  <li><a href="http://jcjc-dev.com/2016/06/08/reversing-huawei-4-dumping-flash/">Part 4</a>:
Dumping the Flash</li>
  <li><strong>Part 5</strong>: Digging Through the Firmware</li>
</ul>

<p>In part 4 we extracted the entire firmware from the router and decompressed it.
As I explained then, you can often get most of the firmware directly from
the manufacturer’s website: Firmware upgrade binaries often contain partial or
entire filesystems, or even entire firmwares.</p>

<p>In this post we’re gonna dig through the firmware to find potentially
interesting code, common vulnerabilities, etc.</p>

<p>I’m gonna explain some basic theory on the Linux architecture, disassembling
binaries, and other related concepts. Feel free to skip some of the parts
marked as [Theory]; the real hunt starts at ‘Looking for the Default WiFi
Password Generation Algorithm’. At the end of the day, we’re just: obtaining
source code in case we can use it, using <code class="highlighter-rouge">grep</code> and common sense to find
potentially interesting binaries, and disassembling them to find out how they
work.</p>

<p>One step at a time.</p>

<h2 id="gathering-and-analysing-open-source-components">Gathering and Analysing Open Source Components</h2>

<h4 id="gpl-licenses---what-they-are-and-what-to-expect-theory">GPL Licenses - What They Are and What to Expect [Theory]</h4>

<p>Linux, U-Boot and other tools used in this
router are licensed under the
<strong><a href="https://en.wikipedia.org/wiki/GNU_General_Public_License">General Public License</a></strong>.
This license mandates that the source code for any binaries built with GPL’d
projects must be made available to anyone who wants it.</p>

<p>Having access to all that source code can be a massive advantage during the
reversing process. The kernel and the bootloader are particularly interesting,
and not just to find security issues. For instance:</p>

<p>When hunting for GPL’d sources you can usually expect one of these scenarios:</p>

<ol>
  <li>The code is freely available on the manufacturer’s website, nicely ordered
and completely open to be tinkered with. For instance:
<a href="https://opensource.apple.com/">apple products</a> or the
<a href="https://www.amazon.com/gp/help/customer/display.html?nodeId=201626480">amazon echo</a></li>
  <li>The source code is available by request
    <ul>
      <li>They send you an email with the sources you requested</li>
      <li>They ask you for “a reasonable amount” of money to ship you a CD with
the sources</li>
    </ul>
  </li>
  <li>They decide to (illegally) ignore your requests. If this happens to you,
<a href="https://lists.linuxfoundation.org/pipermail/ksummit-discuss/2016-August/003580.html">consider being nice over trying to get nasty</a>.</li>
</ol>

<p>In the case of this router, the source code was available on their website, even
though it was a huge pain in the ass to find; it took me a long time of manual
and automated searching but I ended up finding it in the mobile version of the
site:</p>

<ul>
  <li><a href="http://m.huawei.com/enmobile/consumer/support/downloads/index.htm">Huawei’s GPL compliance search page</a>.</li>
  <li><a href="http://download-c.huawei.com/download/downloadCenter?downloadId=17643&amp;siteCode=worldwide">HG533 GPL release</a></li>
  <li><a href="https://mega.nz/#!QxADUL5D!6Fga4S5C7ENmgDhhrtQqZcevbH8-3Tj6NEhO7yOV8hI">Mirror of the HG533 release</a>.</li>
</ul>

<p><img src="http://i.imgur.com/rqWb3Jj.png" alt="ls -lh gpl_source"></p>

<p><strong>But what if they’re hiding something!?</strong> How could we possibly tell whether
the sources they gave us are the same they used to compile the production
binaries?</p>

<h4 id="challenges-of-binary-verification-theory">Challenges of Binary Verification [Theory]</h4>

<p>Theoretically, we could try to compile the source code ourselves and compare
the resulting binary with the one we extracted from the device. In practice,
that is extremely more complicated than it sounds.</p>

<p>The exact contents of the binary are strongly tied to the toolchain and overall
environment they were compiled in. We could try to replicate the environment
of the original developers, finding the exact same versions of everything they
used, so we can obtain the same results. Unfortunately, most compilers are not
built with output replicability in mind; even if we managed to find the exact
same version of everything, details like timestamps, processor-specific
optimizations or file paths would stop us from getting a byte-for-byte
identical match.</p>

<p><em>If you’d like to read more about it, I can recommend
<a href="https://madiba.encs.concordia.ca/~x_decarn/papers/verifiable-build-acsac2014.pdf">this paper</a>.
The authors go through the challenges they had to overcome in order to verify
that the official binary releases of the application ‘TrueCrypt’ were not
backdoored.</em></p>

<h4 id="introduction-to-the-architecture-of-linux-theory">Introduction to the Architecture of Linux [Theory]</h4>

<p>In multiple parts of the series, we’ve discussed the different components found
in the firmware: bootloader, kernel, filesystem and some protected memory to
store configuration data. In order to know where to look for what, it’s
important to understand the overall architecture of the system. Let’s quickly
review this device’s:</p>

<p><img src="http://i.imgur.com/2lwcSjA.png" alt="Linux Architecture"></p>

<p>The bootloader is the first piece of code to be executed on boot. Its job is to
prepare the kernel for execution, jump into it and stop running. From that point
on, the kernel controls the hardware and uses it to run user space logic.
A few more details on each of the components:</p>

<ol>
  <li><strong>Hardware</strong>: The CPU, Flash, RAM and other components are all physically
connected</li>
  <li><strong>Linux Kernel</strong>: It knows how to control the hardware. The developers take
the Open Source Linux kernel, write <em>drivers</em> for their specific device
and compile everything into an executable Kernel. It manages memory, reads and
writes hardware registers, etc. In more complex systems, “kernel modules”
provide the possibility of keeping device drivers as separate entities in the
file system, and dynamically load them when required; most embedded systems
don’t need that level of versatility, so developers save precious resources by
compiling everything into the kernel</li>
  <li><strong>libc</strong> (“<em>The C Library</em>”): It serves as a general purpose wrapper for the
System Call API, including extremely common functions like <code class="highlighter-rouge">printf</code>, <code class="highlighter-rouge">malloc</code>
or <code class="highlighter-rouge">system</code>. Developers are free to call the system call API directly, but in
most cases, it’s MUCH more convenient to use libc. Instead of the extremely
common <code class="highlighter-rouge">glibc</code> (GNU C library) we usually find in more powerful systems, this
device uses a version optimised for embedded devices:
<a href="https://www.uclibc.org/"><code class="highlighter-rouge">uClibc</code></a>.</li>
  <li><strong>User Applications</strong>: Executable binaries in <code class="highlighter-rouge">/bin/</code> and <em>shared objects</em>
in <code class="highlighter-rouge">/lib/</code> (libraries that contain functions used by multiple binaries) comprise
most of the high-level logic. Shared objects are used to save space by storing
commonly used functions in a single location</li>
</ol>

<h4 id="bootloader-source-code">Bootloader Source Code</h4>

<p>As I’ve mentioned multiple times over this series, this router’s bootloader is
U-Boot. U-Boot is GPL licensed, but Huawei failed to include the source code in
their website’s release.</p>

<p>Having the source code for the bootloader can be very useful for some projects,
where it can help you figure out how to run a custom firmware on the device
or modify something; some bootloaders are much more feature-rich than others.
In this case, I’m not interested in anything U-Boot has to offer, so I didn’t
bother following up on the source code.</p>

<h4 id="kernel-source-code">Kernel Source Code</h4>

<p>Let’s just check out the source code and look for anything that might help.
Remember the <em>factory reset</em> button? The button is part of the hardware layer,
which means the GPIO pin that detects the button press must be controlled by
the drivers. These are the logs we saw coming out of the UART port in a
previous post:</p>

<p><img src="http://i.imgur.com/u8ZMr4Q.png" alt="UART system restore logs"></p>

<p>With some simple <code class="highlighter-rouge">grep</code> commands we can see how the different components
of the system (kernel, binaries and shared objects) can work together and
produce the serial output we saw:</p>

<p><img src="http://i.imgur.com/ASQBsR6.png" alt="System reset button propagates to user space"></p>

<p>Having the kernel can help us find poorly implemented security-related
algorithms and other weaknesses that are sometimes considered ‘accepted risks’
by manufacturers. Most importantly, we can use the drivers to compile and run
our own OS on the device.</p>

<h4 id="user-space-source-code">User Space Source Code</h4>

<p>As we can see in the GPL release, some components of the user space are also
open source, such as <code class="highlighter-rouge">busybox</code> and <code class="highlighter-rouge">iptables</code>. Given the right (wrong) versions,
public vulnerability databases could be enough to find exploits for any of these.</p>

<p>That being said, if you’re looking for 0-days, backdoors or sensitive data, your
best bet is not the open source projects. Devic specific and closed source code
developed by the manufacturer or one of their providers has not been so heavily
tested and may very well be riddled with bugs. Most of this code is stored as
binaries in the user space; we’ve got the entire filesystem, so we’re good.</p>

<p>Without the source code for user space binaries, we need to find a way to
read the <em>machine code</em> inside them. That’s where disassembly comes in.</p>

<h2 id="binary-disassembly-theory">Binary Disassembly [Theory]</h2>

<p>The code inside every executable binary is just a compilation of instructions
encoded as <em>Machine Code</em> so they can be processed by the CPU. Our processor’s
datasheet will explain the direct equivalence between assembly instructions and
their machine code representations. A disassembler has been given that
equivalence so it can go through the binary, find data and machine code and
<a href="https://www.youtube.com/watch?v=2_bJ6Ei6zWo">translate it into assembly</a>.
Assembly is not pretty, but at least it’s human-readable.</p>

<p>Due to the very low-level nature of the kernel, and how heavily it interacts
with the hardware, it is incredibly difficult to make any sense of its binary.
User space binaries, on the other hand, are abstracted away from the hardware
and follow unix standards for calling conventions, binary format, etc. They’re
an ideal target for disassembly.</p>

<h4 id="popular-disassemblers">Popular Disassemblers</h4>

<p>There are lots of disassemblers for popular architectures like MIPS; some better
than others both in terms of functionality and usability.
I’d say these 3 are the most popular and powerful disassemblers in the market
right now:</p>

<ul>
  <li><a href="https://www.hex-rays.com/products/ida/">IDA Pro</a>: By far the <strong>most popular</strong>
disassembler/debugger in the market. It is extremely powerful, multi-platform,
and there are loads of users, tutorials, plugins, etc. around it. Unfortunately,
it’s also VERY expensive; a single person license of the <em>Pro</em> version
(required to disassemble MIPS binaries) costs <strong>over $1000</strong></li>
  <li><a href="https://github.com/radare/radare2">Radare2</a>: Completely <strong>Open Source</strong>, uses
<a href="http://radare.org/r/pics.html">an impressively advanced</a> command line
interface, and there’s a great community of hackers around it. On the other
hand, the complex command line interface -necessary for the sheer amount of
features- makes for a rather <strong>steep learning curve</strong></li>
  <li><a href="https://binary.ninja/">Binary Ninja</a>: Not open source, but reasonably priced
at <strong>$100</strong> for a personal license, it’s middle ground between IDA and radare.
It’s still a <strong>very new</strong> tool; it was just released this year, but it’s
improving and gaining popularity day by day. It already works very well for some
architectures, but unfortunately it’s still missing MIPS support (coming soon)
and some other features I needed for these binaries. I look forward to giving it
another try when it’s more mature</li>
</ul>

<p>In order to display the assembly code in a more readable way, all these
disasemblers use a “Graph View”. It provides an intuitive way to follow the
different possible execution flows in the binary:</p>

<p><img src="http://i.imgur.com/ZTXwFZs.png" alt="IDA Small Function Graph View"></p>

<p>Such a clear representation of branches, and their conditionals, loops, etc.
is extremely useful. Without it, we’d have to manually jump from one branch to
another in the
<a href="https://gist.github.com/Palantir555/9f98761544c8e36651bfe9a774e82cbc">raw assembly code</a>.
Not so fun.</p>

<p>If you read the code in that function you can see the disassembler makes a great
job displaying references to functions and hardcoded strings. That might be
enough to help us find something juicy, but in most cases you’ll need to
understand the assembly code to a certain extent.</p>

<h4 id="gathering-intel-on-the-cpu-and-its-assembly-code-theory">Gathering Intel on the CPU and Its Assembly Code [Theory]</h4>

<p>Let’s take a look at the format of our binaries:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ file bin/busybox
bin/busybox: ELF 32-bit LSB executable, MIPS, MIPS-II version 1 (SYSV), dynamically linked (uses shared libs), corrupted section header size
</code></pre>
</div>

<p>Because ELF headers are designed to be platform-agnostic, we can easily find out
some info about our binaries. As you can see, we know the architecture
(32-bit MIPS), <a href="http://www.yolinux.com/TUTORIALS/Endian-Byte-Order.html">endianness</a>
(LSB), and whether it uses shared libraries.</p>

<p>We can verify that information thanks to the Ralink’s
<a href="https://wikidevi.com/files/Ralink/RT3352%20product%20brief.pdf">product brief</a>,
which specifies the processor core it uses: <code class="highlighter-rouge">MIPS24KEc</code></p>

<p><img src="http://i.imgur.com/KgVCwq5.png" alt="Product Brief Highlighted Processor Core"></p>

<p>With the exact version of the CPU core, we can easily find its
<a href="http://wiki.prplfoundation.org/w/images/3/39/MD00445-2B-24KEC-DTS-02.00.pdf">datasheet</a>
as released by the company that designed it:
<a href="https://imgtec.com/tools/mips-tools/linux/">Imagination Technologies</a>.</p>

<p>Once we know the basics we can just drop the binary into the disassembler. It
will help validate some of our findings, and provide us with the assembly code.
In order to understand that code we’re gonna need to know the architecture’s
instruction sets and register names:</p>

<ul>
  <li><a href="https://github.com/MIPT-ILab/mipt-mips/wiki/MIPS-Instruction-Set">MIPS Instruction Set</a></li>
  <li><a href="https://github.com/MIPT-ILab/mipt-mips/wiki/MIPS-pseudo-instructions">MIPS Pseudo-Instructions</a>:
Very simple combinations of basic instructions, used for developer/reverser
convenience</li>
  <li><a href="https://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Mips/altReg.html">MIPS Alternate Register Names</a>:
In MIPS, there’s no real difference between registers; the CPU doesn’t about
what they’re called. Alternate register names exist to make the code more
readable for the developer/reverser: <code class="highlighter-rouge">$a0</code> to <code class="highlighter-rouge">$a3</code> for function arguments,
<code class="highlighter-rouge">$t0</code> to <code class="highlighter-rouge">$t9</code> for temporary registers, etc.</li>
</ul>

<p>Beyond instructions and registers, some architectures may have some quirks. One
example of this would be the presence of
<a href="https://en.wikipedia.org/wiki/Delay_slot">delay slots</a> in MIPS: Instructions
that appear immediately after branch instructions (e.g. <code class="highlighter-rouge">beqz</code>, <code class="highlighter-rouge">jalr</code>) but are
actually executed before the jump. That sort of non-linearity would be
unthinkable in other architectures.</p>

<p><em>Some interesting links if you’re trying to learn MIPS:
<a href="https://www.praetorian.com/blog/reversing-and-exploiting-embedded-devices-part-1-the-software-stack">Intro to MIPS Reversing using Radare2</a>,
<a href="http://courses.missouristate.edu/KenVollmar/MARS/download.htm">MIPS Assembler and Runtime Simulator</a>,
<a href="https://www.linux-mips.org/wiki/Toolchains">Toolchains to cross-compile for MIPS targets</a>.</em></p>

<h4 id="example-of-user-space-binary-disassembly">Example of User Space Binary Disassembly</h4>

<p>Following up on the reset key example we were using for the Kernel, we’ve got
the code that generated <strong>some</strong> of the UART log messages, but not all of them.
Since we couldn’t find the ‘button has been pressed’ string in the kernel’s
source code, we can deduce it must have come from user space. Let’s find out
which binary printed it:</p>

<div class="language-text highlighter-rouge"><pre class="highlight"><code>~/Tech/Reversing/Huawei-HG533_TalkTalk/router_filesystem
$ grep -i -r "restore default success" .
Binary file ./bin/cli matches
Binary file ./bin/equipcmd matches
Binary file ./lib/libcfmapi.so matches
</code></pre>
</div>

<p>3 files contain the next string found in the logs: 2 executables in <code class="highlighter-rouge">/bin/</code> and
1 shared object in <code class="highlighter-rouge">/lib/</code>. Let’s take a look at <code class="highlighter-rouge">/bin/equipcmd</code> with IDA:</p>

<p><img src="http://i.imgur.com/NYu28hi.png" alt="restore success string in /bin/equipcmd - IDA GUI"></p>

<p>If we look closely, we can almost read the C code that was compiled into these
instructions. We can see a “clear configuration file”, which would match the
<code class="highlighter-rouge">ERASE</code> commands we saw in the SPI traffic capture to the flash IC. Then,
depending on the result, one of two strings is printed: <code class="highlighter-rouge">restore default
success</code> or <code class="highlighter-rouge">restore default fail</code> . On success, it then
prints something else, flushes some buffers and reboots; this also matches the
behaviour we observed when we pressed the reset button.</p>

<p>That function is a perfect example of delay slots: the <code class="highlighter-rouge">addiu</code> instructions
that set both strings as arguments -<code class="highlighter-rouge">$a0</code>- for the 2 <code class="highlighter-rouge">puts</code> are in the delay
slots of the <code class="highlighter-rouge">branch if equals zero</code> and <code class="highlighter-rouge">jump and link register</code> instructions.
They will actually be executed before branching/jumping.</p>

<p>As you can see, IDA has the name of all the functions in the binary. That won’t
necessarily be the case in other binaries, and now’s a good time to discuss why.</p>

<h4 id="function-names-in-a-binary---intro-to-symbol-tables-theory">Function Names in a Binary - Intro to Symbol Tables [Theory]</h4>

<p>The ELF format specifies the usage of
<a href="https://blogs.oracle.com/ali/entry/inside_elf_symbol_tables"><em>symbol tables</em></a>:
chunks of data inside a binary that provide useful debugging information. Part
of that information are human-readable names for every function in the binary.
This is extremely convenient for a developer debugging their binary, but in
most cases it should be removed before releasing the production binary. The
developers were nice enough to leave most of them in there :)</p>

<p>In order to remove them, the developers can use tools like
<a href="http://linux.die.net/man/1/strip">strip</a>, which know what must be kept and
what can be spared. These tools serve a double purpose: They save memory by
removing data that won’t be necessary at runtime, and they make the reversing
process much more complicated for potential attackers. Function names give
context to the code we’re looking at, which is massively helpful.</p>

<p>In some cases -mostly when disassembling shared objects- you may see <em>some</em>
function names or none at all. The ones you WILL see are the <strong>Dyn</strong>amic
<strong>Sym</strong>bols in the <code class="highlighter-rouge">.dymsym</code> table: We discussed earlier the massive amount of
memory that can be saved by using shared objects to keep the pieces of code you
need to re-use all over the system (e.g. <code class="highlighter-rouge">printf()</code>). In order to locate pieces
of data inside the shared object, the caller uses their human-readable name.
That means the names for functions and variables that need to be publicly
accessible  <strong>must</strong> be left in the binary. The rest of them can be removed,
which is why ELF uses 2 symbol tables: <code class="highlighter-rouge">.dynsym</code> for publicly accessible
symbols and <code class="highlighter-rouge">.symtab</code> for the internal ones.</p>

<p>For more details on symbol tables and other intricacies of the ELF format, check
out: <a href="https://greek0.net/elf.html">The ELF Format - How programs look from the inside</a>,
<a href="https://blogs.oracle.com/ali/entry/inside_elf_symbol_tables">Inside ELF Symbol Tables</a>
and the <a href="http://flint.cs.yale.edu/cs422/doc/ELF_Format.pdf">ELF spec (PDF)</a>.</p>

<h2 id="looking-for-the-default-wifi-password-generation-algorithm">Looking for the Default WiFi Password Generation Algorithm</h2>

<h4 id="what-do-we-know">What do We Know?</h4>

<p>Remember the wifi password generation algorithm we discussed in part 3?
(<a href="http://jcjc-dev.com/2016/05/23/reversing-huawei-3-sniffing/">The Pot of Gold at the End of the Firmware</a>)
I explained then why I didn’t expect this router to have one, but let’s take a
look anyway.</p>

<p>If you recall, these are the default WiFi credentials in my router:</p>

<p><img src="http://i.imgur.com/ATznq7F.png" alt="Router Sticker - Annotated"></p>

<p>So what do we know?</p>

<ol>
  <li>Each device is pre-configured with a different set of WiFi credentials</li>
  <li>The credentials could be hardcoded at the factory or generated on the device.
Either way, we know from previous posts that both SSID and password are stored
in the reserved area of Flash memory, and they’re right next to each other
    <ul>
      <li>If they were hardcoded at the factory, the router only needs to read them
from a known memory location</li>
      <li>If they are generated in the device and then stored to flash, there must
be an algorithm in the router that -given the same inputs- always generates
the same outputs. If the inputs are public (e.g. the MAC address) and we
can find, reverse and replicate the algorithm, we could calculate default
WiFi passwords for any other router that uses the same algorithm</li>
    </ul>
  </li>
</ol>

<p>Let’s see what we can do with that…</p>

<h4 id="finding-hardcoded-strings">Finding Hardcoded Strings</h4>

<p>Let’s assume there IS such algorithm in the router. Between username and
password, there’s only one string that remains constant across devices:
<code class="highlighter-rouge">TALKTALK-</code>. This string is prepended to the last 6 characters of the MAC
address. If the generation algorithm is in the router, surely this string must
be hardcoded in there. Let’s look it up:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ grep -r 'TALKTALK-' .
Binary file ./bin/cms matches
Binary file ./bin/nmbd matches
Binary file ./bin/smbd matches
</code></pre>
</div>

<p>2 of those 3 binaries (<code class="highlighter-rouge">nmbd</code> and <code class="highlighter-rouge">smbd</code>) are part of
<a href="https://www.samba.org/samba/docs/man/manpages-3/samba.7.html">samba</a>, the
program used to use the USB flash drive as a network storage device.
They’re probably used to identify the router over the network. Let’s take a
look at the other one: <code class="highlighter-rouge">/bin/cms</code>.</p>

<h4 id="reversing-the-functions-that-uses-them">Reversing the Functions that Uses Them</h4>

<p><img src="http://i.imgur.com/qwksBmi.png" alt="IDA TALKTALK-XXXXXX String Being Built"></p>

<p>That looks exactly the way we’d expect the SSID generation algorithm to look.
The code is located inside a rather large function called <code class="highlighter-rouge">ATP_WLAN_Init</code>, and
somewhere in there it performs the following actions:</p>

<ol>
  <li>Find out the MAC address of the device we’re running on:
    <ul>
      <li><code class="highlighter-rouge">mac = BSP_NET_GetBaseMacAddress()</code></li>
    </ul>
  </li>
  <li>Create the SSID string:
    <ul>
      <li><code class="highlighter-rouge">snprintf(SSID, "TALKTALK-%02x%02x%02x", mac[3], mac[4], mac[5])</code></li>
    </ul>
  </li>
  <li>Save the string somewhere:
    <ul>
      <li><code class="highlighter-rouge">ATP_DBSetPara(SavedRegister3, 0xE8801E09, SSID)</code></li>
    </ul>
  </li>
</ol>

<p>Unfortunately, right after this branch the function simply does an
<code class="highlighter-rouge">ATP_DBSave</code> and moves on to start running commands and whatnot. e.g.:</p>

<p><img src="http://i.imgur.com/HVhwFzU.png" alt="ATP_WLAN_Init moves on before you"></p>

<p>Further inspection of this function and other references to <code class="highlighter-rouge">ATP_DBSave</code> did
not reveal anything interesting.</p>

<h4 id="giving-up">Giving Up</h4>

<p>After some time using this process to find potentially relevant pieces of code,
reverse them, and analyse them, I didn’t find anything that looked like the
password generation algorithm. That would confirm the suspicions I’ve had since
we found the default credentials in the <code class="highlighter-rouge">protected</code> flash area: The manufacturer
used proper security techniques and flashed the credentials at the factory,
which is why there is no algorithm. Since the designers manufacture their own
hardware, the decision makes perfect sense for this device. They can do
whatever they want with their manufacturing lines, so they decided to do it
right.</p>

<p>I might take another look at it in the future, or try to find it in some other
router (I’d like to document the process of reversing it), but you should know
this method DOES work for a lot of products. There’s a long history of freely
available default WiFi password generators.</p>

<p>Since we already know how to find relevant code in the filesystem binaries,
let’s see what else we can do with that knowledge.</p>

<h2 id="looking-for-command-injection-vulnerabilities">Looking for Command Injection Vulnerabilities</h2>

<p>One of the most common, easy to find and dangerous vulnerabilities is command
injection. The idea is simple; we find an input string that is gonna be used
as an argument for a shell command. We try to append our own commands and get
them to execute, bypassing any filters that the developers may have implemented.
In embedded devices, such vulnerabilities often result in full root control of
the device.</p>

<p>These vulnerabilities are particularly common in embedded devices due to their
memory constraints. Say you’re developing the web interface used by the users
to configure the device; you want to add the possibility to <code class="highlighter-rouge">ping</code> a
user-defined server from the router, because it’s very valuable information to
debug network problems. You need to give the user the option to define the ping
target, and you need to serve them the results:</p>

<p><img src="http://i.imgur.com/Nkae9G3.png" alt="Router WEB Interface Ping in action"></p>

<p>Once you receive the data of which server to target, you have two options: You
find a library with the ICMP protocol implemented and call it directly from the
web backend, or you could use a single, standard function call and use the
router’s already existing <code class="highlighter-rouge">ping</code> shell command. The later is easier to
implement, saves memory, etc. and it’s the obvious choice. Taking user input
(target server address) and using it as part of a shell command is where the
danger comes in. Let’s see how this router’s web application, <code class="highlighter-rouge">/bin/web</code>,
handles it:</p>

<p><img src="http://i.imgur.com/gRI8fMt.png" alt="/bin/web's ping function"></p>

<p>A call to libc’s <a href="http://man7.org/linux/man-pages/man3/system.3.html">system()</a>
(not to be confused with a
<em>system call</em>/<a href="http://man7.org/linux/man-pages/man2/syscalls.2.html">syscall</a>)
is the easiest way to execute a shell command from an application. Sometimes
developers wrap <code class="highlighter-rouge">system()</code> in custom functions in order to systematically filter
all inputs, but there’s always something the wrapper can’t do or some developer
who doesn’t get the memo.</p>

<p>Looking for references to <code class="highlighter-rouge">system</code> in a binary is an excellent way to find
vectors for command injections. Just investigate the ones that look like may
be using unfiltered user input. These are all the references to <code class="highlighter-rouge">system()</code> in
the <code class="highlighter-rouge">/bin/web</code> binary:</p>

<p><img src="http://i.imgur.com/x2oflih.png" alt="xrefs to system in /bin/web"></p>

<p>Even the names of the functions can give you clues on whether or not a reference
to <code class="highlighter-rouge">system()</code> will receive user input. We can also see some references to
PIN and PUK codes, SIMs, etc. Seems like this application is also used in some
mobile product…</p>

<p>I spent some time trying to find ways around the filtering provided by
<code class="highlighter-rouge">atp_gethostbyname</code> (anything that isn’t a domain name causes an error), but I
couldn’t find anything in this field or any others. Further analysis may prove
me wrong. The idea would be to inject something to the effects of this:</p>

<p><img src="http://i.imgur.com/bPv4AxJ.png" alt="Attempt reboot injection on ping field"></p>

<p>Which would result in this final string being executed as a shell command:
<code class="highlighter-rouge">ping google.com -c 1; reboot; ping 192.168.1.1 &gt; /dev/null</code>. If the router
reboots, we found a way in.</p>

<p>As I said, I couldn’t find anything. Ideally we’d like to verify that for all
input fields, whether they’re in the web interface or some other network
interface. Another example of a network interface
<a href="https://www.pentestpartners.com/blog/tr-064-worm-its-not-mirai-and-the-outages-are-interesting/">potentially vulnerable</a>
to remote command injections is the “LAN-Side DSL CPE Configuration” protocol,
or <strong>TR-064</strong>. Even though this protocol was designed to be used over the
internal network only, it’s been used to configure routers over the internet in
the past. Command injection vulnerabilities in some implementations of this
protocol have been used to remotely extract data like WiFi credentials from
routers with just a few packets.</p>

<p>This router has a binary conveniently named <code class="highlighter-rouge">/bin/tr064</code>; if we take a look,
we find this right in the <code class="highlighter-rouge">main()</code> function:</p>

<p><img src="http://i.imgur.com/V19ESAp.png" alt="/bin/tr064 using /etc/serverkey.pem"></p>

<p>That’s the private RSA key we found in
<a href="http://jcjc-dev.com/2016/04/29/reversing-huawei-router-2-scouting-firmware/">Part 2</a>
being used for SSL authentication. Now we might be able to supplant a router
in the system and look for vulnerabilities in their servers, or we might use it
to find other attack vectors. Most importantly, it closes the mistery of the
private key we found while scouting the firmware.</p>

<h2 id="looking-for-more-complex-vulnerabilities-theory">Looking for More Complex Vulnerabilities [Theory]</h2>

<p>Even if we couldn’t find any command injection vulnerabilities, there are always
other vectors to gain control of the router. The most common ones are good old
buffer overflows. Any input string into the router, whether it is for a shell
command or any other purpose, is handled, modified and passed around the code.
An error by the developer calculating expected buffer lengths, not validating
them, etc. in those string operations can result in an exploitable buffer
overflow, which an attacker can use to gain control of the system.</p>

<p>The idea behind a buffer overflow is rather simple: We manage to pass a string
into the system that contains executable code. We override some address in the
program so the execution flow jumps into the code we just injected. Now we can
do anything that binary could do -in embedded systems like this one, where
everything runs as root, it means immediate root pwnage.</p>

<p><img src="http://i.imgur.com/hbRsOrE.png" alt="Introducing an unexpectedly long input"></p>

<p>Developing an exploit for this sort of vulnerability is not as simple as
appending commands to find your way around a filter. There are multiple possible
scenarios, and different techniques to handle them. Exploits using more involved
techniques like
<a href="https://en.wikipedia.org/wiki/Return-oriented_programming">ROP</a> can become
necessary in some cases. That being said, most household embedded systems
nowadays are decades behind personal computers in terms of anti-exploitation
techniques. Methods like <em>Address Space Layout Randomization</em>
(<a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">ASLR</a>),
which are designed to make exploit development much more complicated, are
usually disabled or not implemented at all.</p>

<p>If you’d like to find a potential vulnerability so you can learn exploit
development on your own, you can use the same techniques we’ve been using so
far. Find potentially interesting inputs, locate the code that manages them
using function names, hardcoded strings, etc. and try to trigger a malfunction
sending an unexpected input. If we find an improperly handled string, we might
have an exploitable bug.</p>

<p>Once we’ve located the piece of disassembled code we’re going to attack, we’re
mostly interested in string manipulation functions like <code class="highlighter-rouge">strcpy</code>, <code class="highlighter-rouge">strcat</code>,
<code class="highlighter-rouge">sprintf</code>, etc. Their more secure counterparts <code class="highlighter-rouge">strncpy</code>, <code class="highlighter-rouge">strncat</code>, etc. are
also potentially vulnerable to some techniques, but usually much more
complicated to work with.</p>

<p><img src="http://i.imgur.com/JNFw0Od.png" alt="Pic of strcpy handling an input"></p>

<p>Even though I’m not sure that function -extracted from <code class="highlighter-rouge">/bin/tr064</code>- is passed
any user inputs, it’s still a good example of the sort of code you should be
looking for. Once you find potentially insecure string operations that may
handle user input, you need to figure out whether there’s an exploitable bug.</p>

<p>Try to cause a crash by sending unexpectedly long inputs and work from there.
Why did it crash? How many characters can I send without causing a crash? Which
payload can I fit in there? Where does it land in memory? etc. etc. I may write
about this process in more detail at some point, but there’s plenty of
literature available online if you’re interested.</p>

<p>Don’t spend all your efforts on the most obvious inputs only -which are also
more likely to be properly filtered/handled-; using tools like the
<a href="https://portswigger.com/burp/">burp</a> web proxy (or even the browser itself),
we can modify fields like cookies to check for buffer overflows.</p>

<p>Web vulnerabilities like
<a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery">CSRF</a> are also
extremely common in embedded devices with web interfaces. Exploiting them to
write to files or bypass authentication can lead to absolute control of the
router, specially when combined with command injections.
An authentication bypass for a router with the web interface available from
the Internet could very well expose the network to being remotely <em>man in the
middle’d</em>. They’re definitely an important attack vector, even though I’m not
gonna go into how to find them.</p>

<h2 id="decompiling-binaries-theory">Decompiling Binaries [Theory]</h2>

<p>When you decompile a binary, instead of simply translating Machine Code to
Assembly Code, the decompiler uses algorithms to identify functions, loops,
branches, etc. and replicate them in a higher level language like C or Python.</p>

<p>That sounds like a brilliant idea for anybody who has been banging their head
against some assembly code for a few hours, but an additional layer of
abstraction means more potential errors, which can result in massive wastes of
time.</p>

<p>In my (admittedly short) personal experience, the output just doesn’t look
reliable enough. It might be fine when using expensive decompilers (IDA itself
supports a couple of architectures), but I haven’t found one I can trust with
MIPS binaries. That being said, if you’d like to give one a try, the
<a href="https://retdec.com/decompilation/">RetDec</a>
online decompiler supports multiple architectures- including MIPS.</p>

<p><img src="http://i.imgur.com/mhSK5I4.png" alt="Binary Decompiled to C by RetDec"></p>

<p>Even as a ‘high level’ language, the code is not exactly pretty to look at.</p>

<h2 id="next-steps">Next Steps</h2>

<p>Whether we want to learn something about an algorithm we’re reversing, to debug
an exploit we’re developing or to find any other sort of vulnerability, being
able to execute (and, if possible, debug) the binary on an environment we fully
control would be a massive advantage. In some/most cases -like this router-,
being able to debug on the original hardware is not possible. In the next post,
we’ll work on CPU emulation to debug the binaries in our own computers.</p>

<p><em>Thanks for reading! I’m sorry this post took so long to come out. Between work,
<a href="https://hardwear.io">hardwear.io</a> and seeing family/friends, this post was
written about 1 paragraph at a time from 4 different countries. Things should
slow down for a while, so hopefully I’ll be able to publish Part 6 soon. I’ve
also got some other reversing projects coming down the pipeline,
starting with hacking the Amazon Echo and a router with JTAG. I’ll try to get
to those soon, work permitting… Happy Hacking :)</em></p>

<hr>

<h2 id="tips-and-tricks">Tips and Tricks</h2>

<h4 id="mistaken-xrefs-and-how-to-remove-them">Mistaken xrefs and how to remove them</h4>

<p>Sometimes an address is loaded into a register for 16bit/32bit adjustments.
The contents of that address have no effect on the rest of the code; it’s just
a routinary adjustment. If the address that is assigned to the register happens
to be pointing to some valid data, IDA will rename the address in the assembly
and display the contents in a comment.</p>

<p>It is up to you to figure out whether an x-ref makes sense or not. If it
doesn’t, select the variable and press <code class="highlighter-rouge">o</code> in IDA to ignore the contents and
give you only the address. This makes the code much less confusing.</p>

<h4 id="setting-function-prototypes-so-ida-comments-the-args-around-calls-for-us">Setting function prototypes so IDA comments the args around calls for us</h4>

<p>Set the cursor on a function and press <code class="highlighter-rouge">y</code>. Set the prototype for the function:
e.g. <code class="highlighter-rouge">int memcpy(void *restrict dst, const void *restrict src, int n);</code>.
Note:IDA only understands built-in types, so we can’t use types like <code class="highlighter-rouge">size_t</code>.</p>

<p>Once again we can use the <code class="highlighter-rouge">extern</code> declarations found in the GPL source code.
When available, find the declaration for a specific function, and use the same
types and names for the arguments in IDA.</p>

<h4 id="taking-advantage-of-the-gpl-source-code">Taking Advantage of the GPL Source Code</h4>

<p>If we wanna figure out what are the 1st and 2nd parameters of a function like
<code class="highlighter-rouge">ATP_DBSetPara</code>, we can sometimes rely on the GPL source code. Lots of functions
are not implemented in the kernel or any other open source component, but
they’re still used from one of them. That means we can’t see the code we’re
interested in, but we can see the <code class="highlighter-rouge">extern</code> declarations for it. Sometimes the
source will include documentation comments or descriptive variable names; very
useful info that the disassembly doesn’t provide:</p>

<p><img src="http://i.imgur.com/Yh6VhRK.png" alt="ATP_DBSetPara extern declaration in gpl_source/inc/cfmapi.h"></p>

<p>Unfortunately, the function documentation comment is not very useful in this
case -seems like there were encoding issues with the file at some point, and
everything written in Chinese was lost. At least now we know that the first
argument is a list of keys, and the second is something they call <code class="highlighter-rouge">ParamCMO</code>.
<code class="highlighter-rouge">ParamCMO</code> is a constant in our disassembly, so it’s <strong>probably</strong> just a
reference to the key we’re trying to set.</p>

<h4 id="disassembly-methods---linear-sweep-vs-recursive-descent">Disassembly Methods - Linear Sweep vs Recursive Descent</h4>

<p>The structure of a binary can vary greatly depending on compiler, developers,
etc. How functions call each other is not always straightforward for a
disassembler to figure out. That means you may run into lots of ‘orphaned’
functions, which exist in the binary but do not have a known caller.</p>

<p>Which disassembler you use will dictate whether you see those functions or not,
some of which can be extremely important to us (e.g. the <code class="highlighter-rouge">ping</code> function in the
<code class="highlighter-rouge">web</code> binary we reversed earlier). This is due to how they scan binaries for
content:</p>

<ol>
  <li><em>Linear Sweep</em>: Read the binary one byte at a time, anything that looks
like a function is presented to the user. This requires significant logic to
keep false positives to a minimum</li>
  <li><em>Recursive Descent</em>: We know the binary’s entry point. We find all functions
called from <code class="highlighter-rouge">main()</code>, then we find the functions called from those, and keep
recursively displaying functions until we’ve got “all” of them. This method
is very robust, but any functions not referenced in a standard/direct way will
be left out</li>
</ol>

<p>Make sure your disassembler supports linear sweep if you feel like you’re
missing any data. Make sure the code you’re looking at makes sense if you’re
using linear sweep.</p>

</div>

<iframe id="twitter-widget-0" scrolling="no" frameborder="0" allowtransparency="true" class="twitter-share-button twitter-share-button-rendered twitter-tweet-button" title="Twitter Tweet Button" src="http://platform.twitter.com/widgets/tweet_button.b8b8e09be0884a395c5ae18831ce1cc0.en.html#dnt=false&amp;id=twitter-widget-0&amp;lang=en&amp;original_referer=http%3A%2F%2Fjcjc-dev.com%2F2016%2F12%2F14%2Freversing-huawei-5-reversing-firmware%2F&amp;size=m&amp;text=Practical%20Reverse%20Engineering%20Part%205%20-%20Digging%20Through%20the%20Firmware%20%C2%B7%20Hack%20The%20World&amp;time=1486149622410&amp;type=share&amp;url=http%3A%2F%2Fjcjc-dev.com%2F2016%2F12%2F14%2Freversing-huawei-5-reversing-firmware%2F&amp;via=Palantir555" style="position: static; visibility: visible; width: 61px; height: 20px;"></iframe>
<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/2016/06/08/reversing-huawei-4-dumping-flash/">
            Practical Reverse Engineering Part 4 - Dumping the Flash
            <small>08 Jun 2016</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2016/05/23/reversing-huawei-3-sniffing/">
            Practical Reverse Engineering Part 3 - Following the Data
            <small>23 May 2016</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2016/04/29/reversing-huawei-router-2-scouting-firmware/">
            Practical Reverse Engineering Part 2 - Scouting the Firmware
            <small>29 Apr 2016</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

<div id="disqus_thread"><iframe id="dsq-app1" name="dsq-app1" allowtransparency="true" frameborder="0" scrolling="no" tabindex="0" title="Disqus" width="100%" src="https://disqus.com/embed/comments/?base=default&amp;version=e4d6b825474d970581f8906da3f0481c&amp;f=jcjc-dev&amp;t_i=-2016-12-14-reversing-huawei-5-reversing-firmware-&amp;t_u=http%3A%2F%2Fjcjc-dev.com%2F2016%2F12%2F14%2Freversing-huawei-5-reversing-firmware%2F&amp;t_d=Practical%20Reverse%20Engineering%20Part%205%20-%20Digging%20Through%20the%20Firmware&amp;t_t=Practical%20Reverse%20Engineering%20Part%205%20-%20Digging%20Through%20the%20Firmware&amp;s_o=default" style="width: 1px !important; min-width: 100% !important; border: none !important; overflow: hidden !important; height: 0px !important;" horizontalscrolling="no" verticalscrolling="no"></iframe></div>
<script>
/**
* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
*/

var disqus_config = function () {
this.page.url = "http://jcjc-dev.com/2016/12/14/reversing-huawei-5-reversing-firmware/";
this.page.identifier = "-2016-12-14-reversing-huawei-5-reversing-firmware-";
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');

s.src = '//jcjc-dev.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the &lt;a href="https://disqus.com/?ref_noscript" rel="nofollow"&gt;comments powered by Disqus.&lt;/a&gt;</noscript>

  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

    </div>

  

<iframe style="display: none;"></iframe></body></html>